
# Copyright 2024.
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt)

import sys
import subprocess
import re
import collections
from pprint import pprint
import difflib
import itertools
import operator
import string

PREFIX = '//$'

def print_llvm_objdump_version(llvm_objdump_path):
    llvm_objdump_version = subprocess.run([llvm_objdump_path, '--version'], capture_output=True, text=True)
    if len(llvm_objdump_version.stderr) > 0 or llvm_objdump_version.returncode != 0:
        sys.exit(1)
    print('llvm-objdump version output:\n', ''.join(llvm_objdump_version.stdout.splitlines(True)[:2]))

def llvm_objdump_disassembly(llvm_objdump_path, target):
    disasm_result = subprocess.run([llvm_objdump_path, '-d', '--no-leading-addr', '--no-show-raw-insn', '--demangle', '--symbolize-operands', '--x86-asm-syntax=intel', target], capture_output=True, text=True)
    if len(disasm_result.stderr) > 0:
        print('Disassembly error: {} (return code: {})'.format(disasm_result.stderr, disasm_result.returncode))
        sys.exit(1)
    if disasm_result.returncode != 0:
        print('Disassembly return code: {}'.format(disasm_result.returncode))
        sys.exit(1)
    # print(disasm_result.stdout)
    return disasm_result.stdout

def parse_disassembly(raw_string):
    disasm_target_list = []

    for line in raw_string.splitlines():
        if function_name := re.match(r'<.*?(\S+)\(.*\)>', line):
            disasm_target_list.append((function_name[1], []))
        elif len(disasm_target_list) != 0 and len(instruction := line.strip()) != 0 and not instruction.startswith('Disassembly of section'):
            # Filter out endbr64/32 that gets generated by GCC and nop that gets generated for alignment
            if ('endbr64' in instruction) or ('endbr32' in instruction) or ('nop' in instruction):
                continue
            cleaned_instruction = re.sub(r'\s+', ' ', instruction).partition('#')[0].strip()
            if len(cleaned_instruction) == 0:
                continue
            converted_instruction = re.sub(r'(\W|\A)(\d+)(\W|\Z)', lambda m: (m[1] + hex(int(m[2])) + m[3]), cleaned_instruction)

            disasm_target_list[-1][1].append(converted_instruction + '\n')

    return dict(disasm_target_list)

def parse_expected_disassembly(file_path):
    expected_disasm = []
    with open(file_path) as src_file:
        section = None
        for idx, line in enumerate(src_file, start=1):
            exp = line.partition(PREFIX)[2].strip()
            if exp == '': continue

            if fn := re.match(r'@(.+?)\s*(?:{(.+)})?\s*:', exp):
                fn_name, compilers = fn[1], fn[2]

                if section is not None:
                    expected_disasm.append(section)

                section = (fn_name, compilers and compilers.lower(), [])
            else:
                section[2].append((idx, exp + '\n'))
        if section is not None:
            expected_disasm.append(section)

    return expected_disasm

def difference_with_line_numbers(difference):
    max_number_length = max(len(str(line_num or '')) for line_num, _ in difference)
    for line_num, lines in difference:
        for i, line in enumerate(lines):
            yield '{} {}'.format(str((i == 0 and line_num) or '').ljust(max_number_length), line)

def parse_compiler_version(version_string):
    splitted_version_string = version_string.split('.')
    return tuple(itertools.chain(map(int, splitted_version_string), [0] * (4 - len(splitted_version_string))))

def incomplete_parse_compiler_version(version_string):
    return tuple(map(int, version_string.split('.')))


def find_condition_version(cond):
    idx = cond.rfind(' ')
    if (idx + 1) < len(cond) and cond[idx + 1] in ('<', '>', *string.digits):
        return cond[:idx], cond[idx:].strip()
    return cond, ''

def check_version(specified_version, version):
    if len(version) == 0:
        return True
    elif version[0] == '<':
        return specified_version < parse_compiler_version(version[1:])
    elif version[0] == '>':
        return specified_version > parse_compiler_version(version[1:])
    elif version_range := re.match(r'([\d\.]+)\.\.<?([\d\.]+)$', version):
        start_ver = parse_compiler_version(version_range[1])
        end_ver = parse_compiler_version(version_range[2])
        return start_ver <= specified_version and specified_version < end_ver
    else:
        incom_ver = incomplete_parse_compiler_version(version)
        return specified_version[:len(incom_ver)] == incom_ver

def match_condition(specified_conditions, conditions):
    specified_compiler_ids, specified_version = set(specified_conditions[0]), parse_compiler_version(specified_conditions[1])
    for subcondition in conditions.split(','):
        compiler_ids, version = find_condition_version(subcondition.strip())

        if not (set(compiler_id.strip() for compiler_id in compiler_ids.split('&')).issubset(specified_compiler_ids)):
            continue
    
        if check_version(specified_version, version):
            return True
    return False

def compare_disassembly(expected, received):
    total_difference = []
    has_mismatch = False
    line_num_iter = map(operator.itemgetter(0), expected)
    for exp, rec in itertools.zip_longest(map(operator.itemgetter(1), expected), received, fillvalue=''):
        diff = list(filter(lambda x: x.rstrip() not in ('+', '-'), difflib.ndiff((exp, ), (rec, ))))
        if any(line[:2] in ('+ ', '- ') for line in diff):
            has_mismatch = True
        total_difference.append((next(line_num_iter, None), diff))

    return has_mismatch, total_difference

def check_disassembly(expected, received, specified_conditions):
    is_successful = True
    checked_function = 0

    for fn_name, conditions, expected_asm in expected:
        if (resulted_asm := received.get(fn_name, None)) is None:
            print('\nUnknown function name: "{}"\nDid you mean: "{}"?\n'.format(fn_name, '", "'.join(difflib.get_close_matches(fn_name, received.keys(), n=3))))
            sys.exit(1)

        if conditions is None:
            if any(match_condition(specified_conditions, other_conditions) for _, other_conditions, _ in filter(lambda x: x[0] == fn_name and x[1] is not None, expected)):
                continue
                
        elif not match_condition(specified_conditions, conditions):
            continue

        checked_function += 1

        if len(expected_asm) != 0 and expected_asm[0][1].strip() == '[disable]':
            continue

        has_mismatch, difference = compare_disassembly(expected_asm, resulted_asm)
        if has_mismatch:
            print('{}:\n{}'.format(fn_name, ''.join(difference_with_line_numbers(difference))))
            is_successful = False

    if not is_successful:
        sys.exit(1)
    else:
        print('\nSuccessfully completed (functions checked: {})\n'.format(checked_function))

def main():
    llvm_objdump_path = sys.argv[1].strip()
    target_path = sys.argv[2].strip()
    source_path = sys.argv[3].strip()
    specified_conditions = (sys.argv[4].lower().split(';'), sys.argv[5].strip().lower())

    print('Version: {}\nSpecified conditions:\n    {}\n'.format(specified_conditions[1], '\n    '.join(specified_conditions[0])))

    print_llvm_objdump_version(llvm_objdump_path)
    raw_disassembly = llvm_objdump_disassembly(llvm_objdump_path, target_path)
    received_disassembly = parse_disassembly(raw_disassembly)
    expected_disassembly = parse_expected_disassembly(source_path)
    check_disassembly(expected_disassembly, received_disassembly, specified_conditions)

if __name__ == '__main__':
    main()
